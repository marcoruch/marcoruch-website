<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What a Small World - Interactive Visualization | Marco Ruch</title>
    <meta name="description" content="An interactive 3D visualization exploring the small-world phenomenon - how just a few random connections can dramatically shrink the degrees of separation in a network.">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../assets/images/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/images/favicon-16x16.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Montserrat:wght@300;500;700&display=swap" rel="stylesheet">
    
    <!-- Shared Bites Styles -->
    <link rel="stylesheet" href="styles.css">
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Highcharts -->
    <script src="https://cdn.jsdelivr.net/npm/highcharts@11.4.0/highcharts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highcharts@11.4.0/modules/networkgraph.js"></script>
    
    <style>
        /* ===== Page-Specific Styles for Small World Visualization ===== */
        
        /* Visualization Container */
        .viz-container {
            flex: 1;
            min-height: 1000px;
            background: linear-gradient(to bottom, var(--color-off-white), #f5f2ed);
            display: flex;
            flex-direction: column;
        }
        
        .viz-content {
            flex: 1;
            display: flex;
            gap: 2rem;
            padding: 2rem;
            position: relative;
        }
        
        /* Canvas and SVG Visualization */
        #canvas-container {
            flex: 1;
            min-width: 0;
            position: relative;
            background: linear-gradient(to bottom, var(--color-off-white), #f5f2ed);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #canvas-container svg {
            width: 100%;
            height: 100%;
        }
        
        /* D3.js Network Visualization Elements */
        .node {
            fill: var(--color-deep-blue);
            stroke: var(--color-off-white);
            stroke-width: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node:hover {
            fill: var(--color-gold);
            stroke-width: 3px;
        }
        
        .node.selected {
            fill: var(--color-gold);
            stroke: var(--color-deep-blue);
            stroke-width: 3px;
        }
        
        .node.path-node {
            fill: var(--color-gold);
            stroke: var(--color-deep-blue);
            stroke-width: 3px;
        }
        
        .link {
            stroke: var(--color-deep-blue);
            stroke-opacity: 0.4;
            stroke-width: 2px;
            fill: none;
        }
        
        .link.shortcut {
            stroke: var(--color-gold);
            stroke-opacity: 0.8;
            stroke-width: 3px;
        }
        
        .link.path-link {
            stroke: var(--color-dust);
            stroke-opacity: 1;
            stroke-width: 4px;
        }
        
        .cluster-group {
            opacity: 1;
        }
        
        /* Path Visualization Panel */
        .path-panel {
            background: rgba(255, 255, 255, 0.98);
            padding: 1.5rem 2rem;
            border-top: 3px solid var(--color-gold);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            min-height: 160px;
            margin: 0 2rem 2rem 2rem;
        }
        
        .path-panel.has-path .path-content {
            opacity: 1;
        }
        
        .path-content {
            opacity: 0.3;
            transition: opacity var(--transition-normal);
        }
        
        .path-panel.empty .path-title {
            opacity: 0.5;
        }
        
        .path-header {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--color-gold);
        }
        
        .path-title {
            font-family: var(--font-primary);
            font-size: 1.2rem;
            color: var(--color-deep-blue);
        }
        
        .path-steps {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            overflow-x: auto;
            padding: 0.5rem 0;
        }
        
        .path-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }
        
        .step-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--color-gold);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .step-node {
            background: var(--color-deep-blue);
            color: var(--color-off-white);
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            box-shadow: var(--shadow-subtle);
            transition: all var(--transition-normal);
        }
        
        .step-node:hover {
            background: var(--color-gold);
            color: var(--color-deep-blue);
            transform: scale(1.1);
            box-shadow: var(--shadow-elevated);
        }
        
        .step-arrow {
            color: var(--color-gold);
            font-size: 1.5rem;
            margin: 0 0.5rem;
            align-self: center;
            margin-top: 1.5rem;
        }
        
        .path-summary {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(16, 33, 75, 0.2);
            display: flex;
            gap: 2rem;
            font-size: 0.85rem;
        }
        
        .path-metric {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .path-metric-label {
            color: #666;
        }
        
        .path-metric-value {
            font-weight: 700;
            color: var(--color-deep-blue);
            font-size: 1rem;
        }
        
        /* Legend Specific Styles */
        .legend-line.regular {
            background: var(--color-deep-blue);
            opacity: 0.5;
        }
        
        .legend-line.shortcut {
            background: var(--color-gold);
        }
        
        .legend-line.path {
            background: var(--color-dust);
        }
        
        /* Highcharts Network Comparison */
        .network-comparison {
            margin: 3rem 0;
        }
        
        .network-row {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .network-chart {
            flex: 1;
            background: var(--color-off-white);
            border-left: 3px solid var(--color-gold);
            box-shadow: var(--shadow-subtle);
        }
        
        .results-chart {
            width: 100%;
            background: var(--color-off-white);
            border-left: 3px solid var(--color-gold);
            box-shadow: var(--shadow-subtle);
            padding: 1rem;
        }
        
        /* Responsive Overrides */
        @media (max-width: 1200px) {
            #canvas-container {
                min-height: 400px;
            }
        }
        
        @media (max-width: 768px) {
            .path-panel {
                margin: 0 1rem 1rem 1rem;
            }
            
            .viz-container {
                min-height: 400px;
            }
        }
        
        @media (max-width: 1024px) {
            .network-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <header>
            <div class="header-content">
                <a href="../index.html" class="back-link">‚Üê BACK TO PORTFOLIO</a>
                <h1>What a Small World</h1>
                <p class="subtitle">An interactive 3D exploration of how random connections create surprisingly short paths in networks</p>
            </div>
        </header>
        
        <main>
            <div class="viz-container">
                <div class="viz-content">
                    <!-- Left Panel: Network Statistics -->
                    <div class="info-panel">
                        <h3 class="info-title">Network Statistics</h3>
                        <p class="info-text">The small-world phenomenon shows that adding just a few random connections dramatically reduces the average path length between nodes.</p>
                        <div class="stats">
                            <div class="stat-item">
                                <span class="stat-label">Network Type:</span>
                                <span class="stat-value" id="networkType">Clustered</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Total Nodes:</span>
                                <span class="stat-value" id="nodeCount">256</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Path Length:</span>
                                <span class="stat-value" id="avgPath">-</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Clustering Coefficient:</span>
                                <span class="stat-value" id="clustering">-</span>
                            </div>
                        </div>
                        
                        <div class="legend">
                            <h4 class="legend-title">Visual Legend</h4>
                            <div class="legend-item">
                                <div class="legend-icon">
                                    <div class="legend-node"></div>
                                </div>
                                <span class="legend-text">Network Node</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon">
                                    <div class="legend-line regular"></div>
                                </div>
                                <span class="legend-text">Regular Connection</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon">
                                    <div class="legend-line shortcut"></div>
                                </div>
                                <span class="legend-text">Random Shortcut</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon">
                                    <div class="legend-line path"></div>
                                </div>
                                <span class="legend-text">Shortest Path</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Center: 3D Visualization -->
                    <div id="canvas-container">
                        <div class="loading">
                            <div class="loading-spinner"></div>
                            <p>Initializing visualization...</p>
                        </div>
                    </div>
                    
                    <!-- Right Panel: Controls -->
                    <div class="controls-panel">
                        <h3 class="controls-title">Network Controls</h3>
                        <p class="info-text">Select different network modes and see how the average path becomes shorter.</p>
                        
                        <div class="control-group first-control">
                            <label>Network Type</label>
                            <div class="radio-group">
                                <label class="radio-option">
                                    <input type="radio" name="networkType" value="clustered" checked>
                                    <span class="radio-label">Clustered</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="networkType" value="smallworld">
                                    <span class="radio-label">Small World</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="networkType" value="random">
                                    <span class="radio-label">Random</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="control-group" id="shortcutControl" style="display: none;">
                            <label>Shortcut Probability</label>
                            <div class="slider-container">
                                <input type="range" id="shortcutSlider" min="0" max="20" value="5" step="1">
                                <span class="slider-value" id="shortcutValue">5%</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>Path Finding</label>
                            <button class="btn btn-secondary" id="randomPath">Random Path</button>
                            <button class="btn btn-secondary" id="findPath">Define Custom Path</button>
                        </div>
                        
                        <div id="selectionMode" class="selection-mode" style="display: none;">
                            Click a node to select
                        </div>
                    </div>
                </div>
                
                <!-- Bottom: Path Visualization -->
                <div id="pathPanel" class="path-panel empty">
                    <div class="path-header">
                        <h3 class="path-title">Shortest Path Visualization</h3>
                    </div>
                    <div class="path-content">
                        <div class="path-steps" id="pathSteps">
                            <div class="path-step">
                                <div class="step-label">Waiting</div>
                                <div class="step-node" style="opacity: 0.3;">-</div>
                            </div>
                        </div>
                        <div class="path-summary">
                            <div class="path-metric">
                                <span class="path-metric-label">Total Hops:</span>
                                <span class="path-metric-value" id="pathHops">-</span>
                            </div>
                            <div class="path-metric">
                                <span class="path-metric-label">From Node:</span>
                                <span class="path-metric-value" id="pathStart">-</span>
                            </div>
                            <div class="path-metric">
                                <span class="path-metric-label">To Node:</span>
                                <span class="path-metric-value" id="pathEnd">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
        
        <section class="explanation">
            <div class="explanation-content">
                <h2 class="section-header">Understanding the Small-World Problem</h2>
                <p class="section-intro">
                    The small-world phenomenon reveals that in large networks, most nodes can be reached from any other through a surprisingly small number of steps, often just six degrees of separation. This occurs when a network combines local clustering (tight-knit groups) with a few random long-distance connections.
                </p>
                
                <blockquote class="highlight-quote">
                    Consider sending a message through close friends in Switzerland. If you only rely on your immediate friend circle and their close friends, it might take a dozen or more hops to reach someone in Geneva when you're based in Zurich. Each step moves through tightly clustered local networks. However, if you happen to know someone from Thailand or the United States you met while traveling, that single connection suddenly opens an entirely different network. What would have required many local hops can now be achieved in just 2-3 steps by leveraging that one long-distance bridge. This is the core mechanism behind "six degrees of separation" and why seemingly random acquaintances can create surprisingly short paths to distant parts of a network.
                </blockquote>
                
                <div class="network-comparison">
                    <h3 class="section-header">Network Evolution</h3>
                    <div class="network-row">
                        <div id="regularNetwork" class="network-chart"></div>
                        <div id="smallWorldNetwork" class="network-chart"></div>
                        <div id="randomNetwork" class="network-chart"></div>
                    </div>
                    
                    <p class="chart-explanation">The three diagrams above show the evolution from clustered to random networks. The <strong>Regular (p=0)</strong> network displays a perfect circular structure where each node connects only to its immediate neighbors, creating long path lengths but high clustering. The <strong>Small-World (p‚âà0.05)</strong> network introduces just a few random shortcuts (shown in red), dramatically reducing path length while preserving most of the local clustering. The <strong>Random (p=1)</strong> network shows what happens with maximum rewiring - short paths but no meaningful clustering.</p>
                    
                    <div class="results-chart">
                        <div id="resultsChart" style="width: 100%; height: 100%;"></div>
                    </div>
                    
                    <p class="chart-explanation">The graph above illustrates this mathematically: as rewiring probability increases, the clustering coefficient (blue line) stays relatively high until p‚âà0.1, while the path length (gold line) drops rapidly even with minimal rewiring. The highlighted region shows the "sweet spot" where small-world properties emerge - networks that are both highly clustered locally and efficiently connected globally.</p>
                    </div>
                
                <h3 class="section-header">Real-World Applications</h3>
                
                <div class="flowing-explanation">
                    <p>This principle appears everywhere in nature and technology. <strong>Neural networks</strong> in your brain use shortcuts to pass signals efficiently across distant regions while clustering handles specialized tasks, enabling both fast processing and robust, localized function. <strong>Global infrastructure</strong> like air travel relies on local regional airports (clusters) connected by a handful of global hubs (shortcuts), making worldwide travel possible without requiring direct routes between every city pair.</p>
                    
                    <p>Understanding small-world networks also helps predict and manage <strong>information spread</strong>. Diseases and information spread slowly within tight clusters, but a single bridge traveler or viral share can accelerate global reach. This knowledge is crucial for designing better networks, predicting cascading effects, and optimizing everything from social media algorithms to transportation systems.</p>
                </div>
                
                <div class="info-box">
                    <h3 class="section-header">Try It Yourself</h3>
                    <p>Use the controls above to explore how shortcuts transform the network:</p>
                    <ul>
                        <li>Toggle to <strong>Small World</strong> and adjust the shortcut slider. Watch how the average path length drops dramatically with just a few random connections.</li>
                        <li>Click <strong>Find Shortest Path</strong> and select two distant nodes. Compare path lengths in clustered vs. small-world networks.</li>
                        <li>Notice the clustering coefficient stays high even as shortcuts shrink the network. This balance is key to real-world efficiency.</li>
                    </ul>
                </div>
                
                <div class="technical-note">
                    <h4>Technical Note</h4>
                    <p>
                        The above visualizations are based on the Watts-Strogatz model (1998), which demonstrated that random shortcuts reduce average path length dramatically while barely affecting the clustering coefficient. The clustering coefficient measures how connected a node's neighbors are to each other, while average path length tracks the typical number of steps between random nodes. This balance between local structure and global efficiency is what makes small-world networks so prevalent in nature and engineered systems.
                    </p>
                    <p>
                        This bite was inspired by Veritasium's video <a href="https://www.youtube.com/watch?v=CYlon2tvywA" target="_blank" rel="noopener noreferrer" style="color: var(--color-gold); text-decoration: underline;">"Something Strange Happens When You Trace How Connected We Are"</a>, which beautifully explains the math behind six degrees of separation.
                    </p>
                </div>
            </div>
        </section>
    </div>
    
    <script>
        // ===== Network Graph Class =====
        class NetworkGraph {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.networkType = 'clustered'; // 'clustered', 'smallworld', 'random'
                this.shortcutProbability = 0.05;
                this.numClusters = 8; // Number of distinct clusters
                this.nodesPerCluster = 32; // Nodes in each cluster
            }
            
            createClusteredNetwork() {
                this.nodes = [];
                this.edges = [];
                
                const mainRadius = 300; // Radius of the main circle
                const clusterRadius = 80; // Radius of each cluster
                
                // Create clusters arranged in a circle
                for (let c = 0; c < this.numClusters; c++) {
                    const clusterAngle = (2 * Math.PI * c) / this.numClusters;
                    const clusterCenterX = Math.cos(clusterAngle) * mainRadius;
                    const clusterCenterY = Math.sin(clusterAngle) * mainRadius;
                    
                    // Create nodes within each cluster
                    for (let n = 0; n < this.nodesPerCluster; n++) {
                        const nodeAngle = (2 * Math.PI * n) / this.nodesPerCluster;
                        const radius = clusterRadius * (0.3 + Math.random() * 0.7); // Vary radius for organic look
                        
                        const x = clusterCenterX + Math.cos(nodeAngle) * radius;
                        const y = clusterCenterY + Math.sin(nodeAngle) * radius;
                        
                        this.nodes.push({
                            id: c * this.nodesPerCluster + n,
                            x, y,
                            cluster: c,
                            neighbors: []
                        });
                    }
                }
                
                // Connect nodes within clusters (creating tight local networks)
                for (let c = 0; c < this.numClusters; c++) {
                    const clusterStart = c * this.nodesPerCluster;
                    const clusterEnd = clusterStart + this.nodesPerCluster;
                    
                    for (let i = clusterStart; i < clusterEnd; i++) {
                        // Connect to 4-6 neighbors within the same cluster
                        const numConnections = 4 + Math.floor(Math.random() * 3);
                        for (let k = 1; k <= numConnections; k++) {
                            const neighborId = clusterStart + ((i - clusterStart + k) % this.nodesPerCluster);
                            if (!this.nodes[i].neighbors.includes(neighborId)) {
                                this.addEdge(i, neighborId);
                            }
                        }
                    }
                }
                
                // Add a few connections between adjacent clusters
                for (let c = 0; c < this.numClusters; c++) {
                    const nextCluster = (c + 1) % this.numClusters;
                    const clusterStart = c * this.nodesPerCluster;
                    const nextClusterStart = nextCluster * this.nodesPerCluster;
                    
                    // Connect 2-3 nodes from this cluster to the next
                    for (let i = 0; i < 2; i++) {
                        const node1 = clusterStart + Math.floor(Math.random() * this.nodesPerCluster);
                        const node2 = nextClusterStart + Math.floor(Math.random() * this.nodesPerCluster);
                        if (!this.nodes[node1].neighbors.includes(node2)) {
                            this.addEdge(node1, node2);
                        }
                    }
                }
            }
            
            createSmallWorldNetwork() {
                this.createClusteredNetwork();
                
                // Add random shortcuts across different clusters
                const numShortcuts = Math.floor(this.nodes.length * this.shortcutProbability);
                for (let i = 0; i < numShortcuts; i++) {
                    const node1 = Math.floor(Math.random() * this.nodes.length);
                    let node2 = Math.floor(Math.random() * this.nodes.length);
                    
                    // Ensure it's from a different cluster and not already connected
                    let attempts = 0;
                    while ((node2 === node1 || 
                           this.nodes[node1].cluster === this.nodes[node2].cluster ||
                           this.nodes[node1].neighbors.includes(node2)) && 
                           attempts < 50) {
                        node2 = Math.floor(Math.random() * this.nodes.length);
                        attempts++;
                    }
                    
                    if (attempts < 50) {
                        this.addEdge(node1, node2, true); // Mark as shortcut
                    }
                }
            }
            
            createRandomNetwork() {
                this.nodes = [];
                this.edges = [];
                
                const mainRadius = 300; // Radius of the main circle
                const clusterRadius = 80; // Radius of each cluster
                
                // Create nodes in same cluster positions as clustered network
                // but they won't have cluster-based connections
                for (let c = 0; c < this.numClusters; c++) {
                    const clusterAngle = (2 * Math.PI * c) / this.numClusters;
                    const clusterCenterX = Math.cos(clusterAngle) * mainRadius;
                    const clusterCenterY = Math.sin(clusterAngle) * mainRadius;
                    
                    // Create nodes within each cluster
                    for (let n = 0; n < this.nodesPerCluster; n++) {
                        const nodeAngle = (2 * Math.PI * n) / this.nodesPerCluster;
                        const radius = clusterRadius * (0.3 + Math.random() * 0.7);
                        
                        const x = clusterCenterX + Math.cos(nodeAngle) * radius;
                        const y = clusterCenterY + Math.sin(nodeAngle) * radius;
                        
                        this.nodes.push({
                            id: c * this.nodesPerCluster + n,
                            x, y,
                            cluster: c,
                            neighbors: []
                        });
                    }
                }
                
                // Create completely random connections
                // Target similar number of edges as clustered network
                const avgDegree = 5; // Average connections per node
                const numEdges = (this.nodes.length * avgDegree) / 2;
                
                for (let i = 0; i < numEdges; i++) {
                    let node1 = Math.floor(Math.random() * this.nodes.length);
                    let node2 = Math.floor(Math.random() * this.nodes.length);
                    
                    // Ensure it's not the same node and not already connected
                    let attempts = 0;
                    while ((node2 === node1 || this.nodes[node1].neighbors.includes(node2)) && 
                           attempts < 50) {
                        node1 = Math.floor(Math.random() * this.nodes.length);
                        node2 = Math.floor(Math.random() * this.nodes.length);
                        attempts++;
                    }
                    
                    if (attempts < 50) {
                        this.addEdge(node1, node2, false);
                    }
                }
            }
            
            addEdge(from, to, isShortcut = false) {
                this.nodes[from].neighbors.push(to);
                this.nodes[to].neighbors.push(from);
                this.edges.push({ from, to, isShortcut });
            }
            
            findShortestPath(startId, endId) {
                const queue = [[startId]];
                const visited = new Set([startId]);
                
                while (queue.length > 0) {
                    const path = queue.shift();
                    const node = path[path.length - 1];
                    
                    if (node === endId) {
                        return path;
                    }
                    
                    for (const neighbor of this.nodes[node].neighbors) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push([...path, neighbor]);
                        }
                    }
                }
                
                return null;
            }
            
            calculateAveragePathLength() {
                let totalLength = 0;
                let count = 0;
                
                // Sample a subset for performance (all pairs is too slow for 256 nodes)
                const sampleSize = 50;
                for (let i = 0; i < sampleSize; i++) {
                    const node1 = Math.floor(Math.random() * this.nodes.length);
                    const node2 = Math.floor(Math.random() * this.nodes.length);
                    
                    if (node1 !== node2) {
                        const path = this.findShortestPath(node1, node2);
                        if (path) {
                            totalLength += path.length - 1;
                            count++;
                        }
                    }
                }
                
                return count > 0 ? (totalLength / count).toFixed(2) : 0;
            }
            
            calculateClusteringCoefficient() {
                let totalCoeff = 0;
                let nodeCount = 0;
                
                for (const node of this.nodes) {
                    const neighbors = node.neighbors;
                    if (neighbors.length < 2) continue;
                    
                    let connections = 0;
                    for (let i = 0; i < neighbors.length; i++) {
                        for (let j = i + 1; j < neighbors.length; j++) {
                            if (this.nodes[neighbors[i]].neighbors.includes(neighbors[j])) {
                                connections++;
                            }
                        }
                    }
                    
                    const possibleConnections = (neighbors.length * (neighbors.length - 1)) / 2;
                    totalCoeff += connections / possibleConnections;
                    nodeCount++;
                }
                
                return nodeCount > 0 ? (totalCoeff / nodeCount).toFixed(3) : 0;
            }
        }
        
        // ===== D3.js Visualization =====
        class NetworkVisualization {
            constructor() {
                this.svg = null;
                this.g = null;
                this.zoom = null;
                this.graph = new NetworkGraph();
                this.selectedNodes = [];
                this.pathMode = false;
                
                this.init();
                this.createNetwork();
            }
            
            init() {
                const container = document.getElementById('canvas-container');
                const loading = container.querySelector('.loading');
                
                // Clear any existing SVG
                d3.select('#canvas-container svg').remove();
                
                // Create SVG
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.svg = d3.select('#canvas-container')
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Main group for positioning (zoom/pan disabled)
                this.g = this.svg.append('g');
                
                // Center the view (static, no interactive zoom)
                this.g.attr('transform', `translate(${width / 2}, ${height / 2}) scale(0.8)`);
                
                // Window resize handler
                window.addEventListener('resize', () => this.onWindowResize());
                
                loading.style.display = 'none';
            }
            
            createNetwork() {
                // Clear existing visualization
                this.g.selectAll('*').remove();
                
                // Create graph based on network type
                if (this.graph.networkType === 'smallworld') {
                    this.graph.createSmallWorldNetwork();
                } else if (this.graph.networkType === 'random') {
                    this.graph.createRandomNetwork();
                } else {
                    this.graph.createClusteredNetwork();
                }
                
                // Create links
                const links = this.g.append('g')
                    .attr('class', 'links')
                    .selectAll('line')
                    .data(this.graph.edges)
                    .enter()
                    .append('line')
                    .attr('class', d => d.isShortcut ? 'link shortcut' : 'link')
                    .attr('x1', d => this.graph.nodes[d.from].x)
                    .attr('y1', d => this.graph.nodes[d.from].y)
                    .attr('x2', d => this.graph.nodes[d.to].x)
                    .attr('y2', d => this.graph.nodes[d.to].y);
                
                // Create nodes
                const nodes = this.g.append('g')
                    .attr('class', 'nodes')
                    .selectAll('circle')
                    .data(this.graph.nodes)
                    .enter()
                    .append('circle')
                    .attr('class', 'node')
                    .attr('r', 6)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .on('mouseover', function(event, d) {
                        if (!d3.select(this).classed('path-node') && !d3.select(this).classed('selected')) {
                            d3.select(this).attr('r', 9);
                        }
                    })
                    .on('mouseout', function(event, d) {
                        if (!d3.select(this).classed('path-node') && !d3.select(this).classed('selected')) {
                            d3.select(this).attr('r', 6);
                        }
                    });
                
                // Store references
                this.links = links;
                this.nodes = nodes;
                
                this.updateStats();
            }
            
            async showPath(startId, endId) {
                // Reset previous highlights
                this.resetHighlights();
                
                const path = this.graph.findShortestPath(startId, endId);
                if (!path) return;
                
                // Animate path step by step
                for (let i = 0; i < path.length; i++) {
                    const nodeId = path[i];
                    
                    // Highlight current node (just change color, not size)
                    this.nodes.filter(d => d.id === nodeId)
                        .classed('path-node', true);
                    
                    // Highlight edge to this node (if not first)
                    if (i > 0) {
                        const from = path[i - 1];
                        const to = nodeId;
                        
                        this.links.filter(d => 
                            (d.from === from && d.to === to) || 
                            (d.from === to && d.to === from))
                            .classed('path-link', true);
                    }
                    
                    // Update path visualization incrementally
                    this.displayPathVisualizationStep(path.slice(0, i + 1), startId, endId, path.length - 1);
                    
                    // Wait before next step (delay for animation)
                    await new Promise(resolve => setTimeout(resolve, 400));
                }
            }
            
            displayPathVisualizationStep(currentPath, startId, endId, totalHops) {
                const pathStepsContainer = document.getElementById('pathSteps');
                pathStepsContainer.innerHTML = '';
                
                // Create step tiles for current path
                currentPath.forEach((nodeId, index) => {
                    // Add step
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'path-step';
                    
                    const stepLabel = document.createElement('div');
                    stepLabel.className = 'step-label';
                    stepLabel.textContent = index === 0 ? 'Start' : 
                                           (index === currentPath.length - 1 && currentPath.length - 1 === totalHops) ? 'End' : 
                                           `Hop ${index}`;
                    
                    const stepNode = document.createElement('div');
                    stepNode.className = 'step-node';
                    stepNode.textContent = nodeId;
                    
                    stepDiv.appendChild(stepLabel);
                    stepDiv.appendChild(stepNode);
                    pathStepsContainer.appendChild(stepDiv);
                    
                    // Add arrow (except for last node)
                    if (index < currentPath.length - 1) {
                        const arrow = document.createElement('div');
                        arrow.className = 'step-arrow';
                        arrow.textContent = '‚Üí';
                        pathStepsContainer.appendChild(arrow);
                    }
                });
                
                // Update summary
                document.getElementById('pathHops').textContent = totalHops;
                document.getElementById('pathStart').textContent = startId;
                document.getElementById('pathEnd').textContent = endId;
                
                // Show panel with content
                const pathPanel = document.getElementById('pathPanel');
                pathPanel.classList.remove('empty');
                pathPanel.classList.add('has-path');
            }
            
            resetHighlights() {
                this.nodes
                    .classed('path-node', false)
                    .classed('selected', false)
                    .attr('r', 6);
                
                this.links
                    .classed('path-link', false);
            }
            
            updateStats() {
                const typeMap = {
                    'clustered': 'Clustered',
                    'smallworld': 'Small World',
                    'random': 'Random'
                };
                document.getElementById('networkType').textContent = typeMap[this.graph.networkType];
                document.getElementById('nodeCount').textContent = this.graph.nodes.length;
                
                // Calculate stats (this is computationally expensive, so we do it sparingly)
                setTimeout(() => {
                    const avgPath = this.graph.calculateAveragePathLength();
                    const clustering = this.graph.calculateClusteringCoefficient();
                    
                    document.getElementById('avgPath').textContent = avgPath;
                    document.getElementById('clustering').textContent = clustering;
                }, 100);
            }
            
            onWindowResize() {
                const container = document.getElementById('canvas-container');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                this.svg
                    .attr('width', width)
                    .attr('height', height);
                
                // Re-center the view (static positioning)
                this.g.attr('transform', `translate(${width / 2}, ${height / 2}) scale(0.8)`);
            }
        }
        
        // ===== Utility Functions =====
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // ===== Initialize =====
        let viz;
        
        window.addEventListener('DOMContentLoaded', () => {
            viz = new NetworkVisualization();
            
            // Network type radio buttons
            const networkTypeRadios = document.querySelectorAll('input[name="networkType"]');
            networkTypeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    viz.graph.networkType = e.target.value;
                    viz.resetHighlights();
                    viz.createNetwork();
                    
                    const shortcutControl = document.getElementById('shortcutControl');
                    // Show shortcut slider only for small world
                    if (viz.graph.networkType === 'smallworld') {
                        shortcutControl.style.display = 'block';
                    } else {
                        shortcutControl.style.display = 'none';
                    }
                });
            });
            
            // Shortcut slider with debounce
            const debouncedNetworkUpdate = debounce(() => {
                if (viz.graph.networkType === 'smallworld') {
                    viz.createNetwork();
                }
            }, 300);
            
            document.getElementById('shortcutSlider').addEventListener('input', (e) => {
                const value = e.target.value;
                document.getElementById('shortcutValue').textContent = value + '%';
                viz.graph.shortcutProbability = value / 100;
                
                debouncedNetworkUpdate();
            });
            
            // Random path button
            document.getElementById('randomPath').addEventListener('click', () => {
                viz.pathMode = false;
                viz.selectedNodes = [];
                viz.resetHighlights();
                
                // Select two random nodes
                const node1 = Math.floor(Math.random() * viz.graph.nodes.length);
                let node2 = Math.floor(Math.random() * viz.graph.nodes.length);
                
                // Ensure they're different nodes
                while (node2 === node1) {
                    node2 = Math.floor(Math.random() * viz.graph.nodes.length);
                }
                
                // Hide selection mode indicator
                document.getElementById('selectionMode').style.display = 'none';
                
                // Show the path
                viz.showPath(node1, node2);
            });
            
            // Find path button
            document.getElementById('findPath').addEventListener('click', () => {
                viz.pathMode = true;
                viz.selectedNodes = [];
                viz.resetHighlights();
                
                // Reset path panel
                const pathPanel = document.getElementById('pathPanel');
                pathPanel.classList.add('empty');
                pathPanel.classList.remove('has-path');
                document.getElementById('pathSteps').innerHTML = '<div class="path-step"><div class="step-label">Waiting</div><div class="step-node" style="opacity: 0.3;">-</div></div>';
                document.getElementById('pathHops').textContent = '-';
                document.getElementById('pathStart').textContent = '-';
                document.getElementById('pathEnd').textContent = '-';
                
                document.getElementById('selectionMode').style.display = 'block';
                document.getElementById('selectionMode').textContent = 'Select first node...';
                
                // Enable click handlers for nodes
                viz.nodes.on('click', (event, d) => {
                    if (!viz.pathMode) return;
                    
                    event.stopPropagation();
                    
                    viz.selectedNodes.push(d.id);
                    d3.select(event.currentTarget).classed('selected', true);
                    
                    if (viz.selectedNodes.length === 1) {
                        document.getElementById('selectionMode').textContent = 'Select second node...';
                    } else if (viz.selectedNodes.length === 2) {
                        viz.showPath(viz.selectedNodes[0], viz.selectedNodes[1]);
                        viz.selectedNodes = [];
                        viz.pathMode = false;
                        document.getElementById('selectionMode').style.display = 'none';
                    }
                });
            });
            
            // ===== Highcharts Network Visualizations =====
            initNetworkCharts();
        });
        
        function initNetworkCharts() {
            // ===== Utility generators =====
            function circularNodes(N, radius) {
                const nodes = [];
                for (let i = 0; i < N; i++) {
                    const angle = (2 * Math.PI * i) / N;
                    nodes.push({
                        id: String(i),
                        marker: { radius: 2, fillColor: "#10214b" },
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                        connections: 0 // Will be updated when edges are added
                    });
                }
                return nodes;
            }
            
            function regularEdges(N, k) {
                const edges = [];
                for (let i = 0; i < N; i++) {
                    for (let j = 1; j <= k; j++) {
                        edges.push([String(i), String((i + j) % N)]);
                    }
                }
                return edges;
            }
            
            function addShortcuts(edges, N, count) {
                const shortcutEdges = [...edges];
                for (let s = 0; s < count; s++) {
                    const a = Math.floor(Math.random() * N);
                    const b = Math.floor(Math.random() * N);
                    if (a !== b) shortcutEdges.push([String(a), String(b)]);
                }
                return shortcutEdges;
            }
            
            function randomEdges(N, numEdges) {
                const edges = [];
                for (let i = 0; i < numEdges; i++) {
                    const a = Math.floor(Math.random() * N);
                    let b = Math.floor(Math.random() * N);
                    while (b === a) b = Math.floor(Math.random() * N);
                    edges.push([String(a), String(b)]);
                }
                return edges;
            }
            
            // ===== Parameters =====
            const N = 60;
            const k = 4;
            const radius = 280;
            const baseNodes = circularNodes(N, radius);
            
            // ===== Chart templates =====
            function makeNetwork(container, title, edges, color = "#10214b") {
                // Calculate connections for each node
                const nodeConnections = {};
                edges.forEach(edge => {
                    nodeConnections[edge[0]] = (nodeConnections[edge[0]] || 0) + 1;
                    nodeConnections[edge[1]] = (nodeConnections[edge[1]] || 0) + 1;
                });
                
                // Update nodes with connection counts
                const nodesWithConnections = baseNodes.map(node => ({
                    ...node,
                    connections: nodeConnections[node.id] || 0
                }));
                
                Highcharts.chart(container, {
                    chart: {
                        type: "networkgraph",
                        backgroundColor: "#ebe7e1",
                        spacing: [20, 20, 20, 20],
                        margin: [60, 20, 20, 20]
                    },
                    title: {
                        text: title,
                        style: {
                            fontFamily: "'Playfair Display', serif",
                            fontSize: "1.3rem",
                            color: "#10214b",
                            fontWeight: "700"
                        }
                    },
                    credits: { enabled: false },
                    tooltip: {
                        useHTML: true,
                        formatter: function() {
                            if (this.point.id) {
                                return `<b>Node ${this.point.id}</b><br/>Connections: ${this.point.connections || 'N/A'}`;
                            }
                            return false;
                        },
                        style: {
                            fontFamily: "'Montserrat', sans-serif",
                            fontSize: "0.85rem"
                        }
                    },
                    plotOptions: {
                        networkgraph: {
                            keys: ["from", "to"],
                            layoutAlgorithm: { 
                                enableSimulation: false,
                                integration: 'verlet',
                                linkLength: 50,
                                initialPositions: 'circle'
                            }
                        }
                    },
                    series: [{
                        data: edges,
                        nodes: nodesWithConnections,
                        color: color,
                        lineWidth: 1,
                        marker: {
                            radius: 4
                        },
                        dataLabels: {
                            enabled: false
                        }
                    }]
                });
            }
            
            // ===== Networks =====
            makeNetwork("regularNetwork", "Regular (p=0)", regularEdges(N, k), "#10214b");
            makeNetwork("smallWorldNetwork", "Small-World (p‚âà0.05)", addShortcuts(regularEdges(N, k), N, 25), "#d03c3b");
            makeNetwork("randomNetwork", "Random (p=1)", randomEdges(N, N * k), "#d7bd88");
            
            // ===== Results Chart =====
            Highcharts.chart("resultsChart", {
                chart: {
                    backgroundColor: "transparent",
                    spacing: [20, 20, 20, 20]
                },
                credits: { enabled: false },
                title: {
                    text: "Clustering Coefficient and Path Length vs. Rewiring Probability",
                    style: {
                        fontFamily: "'Playfair Display', serif",
                        fontSize: "1.5rem",
                        color: "#10214b",
                        fontWeight: "700"
                    }
                },
                tooltip: {
                    useHTML: true,
                    formatter: function() {
                        const seriesName = this.series.name.includes('Clustering') ? 'Clustering' : 'Path Length';
                        return `<b>${seriesName}</b><br/>p = ${this.x}<br/>Value: ${this.y.toFixed(2)}`;
                    },
                    style: {
                        fontFamily: "'Montserrat', sans-serif",
                        fontSize: "0.85rem"
                    }
                },
                xAxis: {
                    type: "logarithmic",
                    title: {
                        text: "Rewiring probability (p)",
                        style: {
                            fontFamily: "'Montserrat', sans-serif",
                            fontSize: "0.9rem",
                            color: "#10214b"
                        }
                    },
                    min: 0.0001,
                    max: 1,
                    labels: {
                        format: "{value}",
                        style: {
                            fontFamily: "'Montserrat', sans-serif",
                            color: "#10214b"
                        }
                    },
                    gridLineColor: "rgba(16, 33, 75, 0.1)",
                    plotBands: [{
                        from: 0.001,
                        to: 0.1,
                        color: "rgba(16, 33, 75, 0.08)",
                        label: {
                            text: "Small-World Region",
                            style: {
                                fontFamily: "'Montserrat', sans-serif",
                                fontSize: "0.75rem",
                                color: "#10214b",
                                fontWeight: "600"
                            },
                            align: "center",
                            y: 20
                        }
                    }]
                },
                yAxis: {
                    min: 0,
                    max: 1.05,
                    title: {
                        text: "Normalized C(p)/C(0), L(p)/L(0)",
                        style: {
                            fontFamily: "'Montserrat', sans-serif",
                            fontSize: "0.9rem",
                            color: "#10214b"
                        }
                    },
                    labels: {
                        style: {
                            fontFamily: "'Montserrat', sans-serif",
                            color: "#10214b"
                        }
                    },
                    gridLineColor: "rgba(16, 33, 75, 0.1)"
                },
                legend: {
                    enabled: true,
                    itemStyle: {
                        fontFamily: "'Montserrat', sans-serif",
                        fontSize: "0.9rem",
                        color: "#10214b"
                    }
                },
                series: [
                    {
                        name: "C(p)/C(0) - Clustering",
                        type: "spline",
                        color: "#10214b",
                        marker: { symbol: "square" },
                        lineWidth: 3,
                        data: [
                            [0.0001, 1.0],
                            [0.001, 0.97],
                            [0.01, 0.9],
                            [0.1, 0.35],
                            [1.0, 0.01]
                        ]
                    },
                    {
                        name: "L(p)/L(0) - Path Length",
                        type: "spline",
                        color: "#d7bd88",
                        marker: { symbol: "circle" },
                        lineWidth: 3,
                        data: [
                            [0.0001, 1.0],
                            [0.001, 0.8],
                            [0.01, 0.3],
                            [0.1, 0.1],
                            [1.0, 0.05]
                        ]
                    }
                ]
            });
        }
    </script>
</body>
</html>
